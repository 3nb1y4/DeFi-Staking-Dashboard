// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IERC20 {
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function transfer(address to, uint256 amount) external returns (bool);
}

contract TokenStaking {
    IERC20 public stakingToken;

    enum Duration { OneWeek, OneMonth, OneYear }

    struct Stake {
        uint256 amount;
        uint256 startTime;
        uint256 duration;
        bool withdrawn;
    }

    mapping(address => Stake[]) public stakes;

    event Staked(address indexed user, uint256 amount, uint256 duration);
    event Unstaked(address indexed user, uint256 amount, uint256 reward);

    constructor(address _tokenAddress) {
        stakingToken = IERC20(_tokenAddress);
    }

    function stake(uint256 _amount, Duration _duration) external {
        require(_amount > 0, "Amount must be greater than 0");

        uint256 lockDuration;
        if (_duration == Duration.OneWeek) {
            lockDuration = 7 days;
        } else if (_duration == Duration.OneMonth) {
            lockDuration = 30 days;
        } else if (_duration == Duration.OneYear) {
            lockDuration = 365 days;
        }

        // Token'i kontrata çek
        require(stakingToken.transferFrom(msg.sender, address(this), _amount), "Transfer failed");

        // Stake kaydı oluştur
        stakes[msg.sender].push(Stake({
            amount: _amount,
            startTime: block.timestamp,
            duration: lockDuration,
            withdrawn: false
        }));

        emit Staked(msg.sender, _amount, lockDuration);
    }

    function unstake(uint256 _index) external {
        require(_index < stakes[msg.sender].length, "Invalid index");

        Stake storage userStake = stakes[msg.sender][_index];
        require(!userStake.withdrawn, "Already withdrawn");
        require(block.timestamp >= userStake.startTime + userStake.duration, "Stake still locked");

        uint256 reward = calculateReward(userStake.amount, userStake.duration);
        uint256 totalAmount = userStake.amount + reward;

        userStake.withdrawn = true;

        require(stakingToken.transfer(msg.sender, totalAmount), "Transfer failed");

        emit Unstaked(msg.sender, userStake.amount, reward);
    }

    function calculateReward(uint256 _amount, uint256 _duration) internal pure returns (uint256) {
        if (_duration == 7 days) {
            return (_amount * 5) / 100; // %5
        } else if (_duration == 30 days) {
            return (_amount * 15) / 100; // %15
        } else if (_duration == 365 days) {
            return (_amount * 50) / 100; // %50
        } else {
            return 0;
        }
    }

    function getStakes(address _user) external view returns (Stake[] memory) {
        return stakes[_user];
    }
}
